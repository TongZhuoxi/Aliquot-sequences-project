import matplotlib.pyplot as plt
import numpy as np
def q8(n):
#Create lists of abundant, deficient and perfect numbers
    abundant = []
    deficient = []
    perfect = []
    for i in range(1, n+1):
        if s(i) > i:
            abundant.append(i)
        elif s(i) < i:
            deficient.append(i)
        else:
            perfect.append(i)
        a = len(abundant)
        d = len(deficient)
        p = len(perfect)
    print("Up to", n, "there are")
    print(a, "abundant numbers")
    print(d, "deficient numbers")
    print(p, "perfect numbers")
    print(a/d, "is ratio of a to d")
    #we found that most abundant numbers are even
    #explore number proportions of even vs odd deficient integers
    even_d = []
    odd_d = []
    for d in deficient:
        if d % 2 == 0:
            even_d.append(d)
        else:
            odd_d.append(d)
    print ("total odd deficient", len(odd_d))
    print ("total even deficient", len(even_d))
    print(len(odd_d)/len(deficient), "proportion of deficient numbers that are odd")
    print(len(even_d)/len(deficient), "proportion of deficient numbers that are even")


#Plot s(n)
def q8plot(n):
    x = np.array(range(1, n+1))
    y = np.array([s(k) for k in x])
    plt.plot(x, y)
    plt.show
q8plot(200)










def type_summation(n):
    #So i'm defining a variable sum to be the summation of all the proper divisors of n
    sum = s(n)
    if sum > n:
        return "abundant"
    elif sum == n:
        return "perfect"
    else:
        return "deficient"

def count_of_sequences(A, k):

    #Again starting at 0 for these
    abundant = 0
    perfect = 0
    deficient = 0

    #Defining a loop that goes from number 1 up to and including A - and for each of these numbers and aliquot sequence is generated
    for n in range(1, A + 1):
        #This part specifically generates the aliquot sequence for that n in the range 1 to A+1 (code from before)
        sequence = a(n, k)

        #Now defining a loop that goes through each term in the sequence and defines them based off of their sum of proper divisors (like above)
        for each_term in sequence:

            #Defining a variable category uses my previous function to classify each of the terms in this specific sequence
            category = type_summation(each_term)

            if category == "abundant":
                abundant = abundant + 1
            elif category == "perfect":
                perfect = perfect + 1
            else:
                deficient = deficient + 1

    print("For terms in aliquot sequences starting from 1 to " + str(A) + " with up to " + str(k) + " terms each:")
    print("Abundant: " +str(abundant))
    print("Perfect: " +str(perfect))
    print("Deficient: " +str(deficient))



# I want to now focus on convergence of aliquot sequences ... i think this is going to be hard! I first need to create some code that will 
# establish the length of aliquot sequences when they end (for whatever reason) - i'm going to essentially add onto/use the code from question 4

def sequence_length(n, k, cutoff):
    
    #Creating a set that initially contains n and used to store terms that haven't repeated yet
    repeats = [n]
    #Currently there's only 1 term in the sequence, so the length is 1
    length = 1

    #Generate k terms 
    for i in range(k - 1):

        #Want to find the next term in the sequence
        next_term = s(n)

        #Ending 1 - terminates at 0
        if next_term == 0:
            length = length + 1
            return "zero", length

        #Ending 2 - term exceeds i
        if next_term > cutoff:
            length = length + 1
            return "cutoff", length 

        #Ending 3 - term repeats
        if next_term in repeats:
            length = length + 1
            return "loop", length

        #If term NOT in 'repeats' - add this term to set of repeats and continue sequence
        repeats.append(next_term)
        n = next_term
        length = length + 1

    #Ending 4 - greater than k terms - has to be this if it's not the others?     
    return "k_limit", length


#Following the pattern of question 4, I now want to use the function I've just created to compute how aliquot sequences behave for every n, in the range (1, m)

# m is the largest starting value, k is the maximum number of terms and cutoff is the largest value a term can have
def convergence(m, k, cutoff):

    #Starting at 0 for each
    zero = loop = cutoff_count = k_limit = 0

    #This will store the length of the sequence for each starting value n
    lengths = []

    #We want to test for each n from 1 up to m 
    for n in range(1, m+1):

        #How does the sequence end and how long is it?
        reason, length = sequence_length(n, k, cutoff)

        #I need this for when I want to start plotting something - it's storing length n=1, length n=2 etc
        lengths.append(length)

        #We want to increase the relevant category
        if reason == "zero":
            zero = zero + 1
        elif reason == "loop":
            loop = loop + 1
        elif reason == "cutoff":
            cutoff_count = cutoff_count + 1
        elif reason == "k_limit":
            k_limit = k_limit + 1

    #adds names
    names = ['Terminates at 0', 'Loops', 'Goes above threshold', 'Goes beyond number of iterations']
    counts = [zero, loop, cutoff_count, k_limit]

    print('The number of sequences that terminate at 0: ' + str(zero))
    print('The number of sequences that terminate at a loop: ' + str(loop))
    print('The number of sequences that terminate because a value of a term has exceeded i: ' + str(cutoff_count))
    print('The number of sequences that terminate because they have more terms than k: ' + str(k_limit))
    print('The lengths are: ' + str(lengths))

    return names, counts, lengths


#Plotting a bar chart first 

m = 2000
k = 70
cutoff = 10**9

#My function convergence(m, k, cutoff) returns 3 things: names, counts, lengths
names, counts, lengths = convergence(m, k, cutoff)

plt.figure(figsize=(10,6))
plt.bar(names, counts)
plt.xticks(rotation=15)
plt.ylabel("Number of starting values")
plt.title("How aliquot sequences end")
plt.show()

#Plotting a scatter graph 

m = 2000
k = 70
cutoff = 10**9

#My function convergence(m, k, cutoff) returns 3 things: names, counts, lengths
names, counts, lengths = convergence(m, k, cutoff)

#This is the set of starting values n, from 1 to m
x_vals = range(1, m+1)
#This is the list of sequence lengths returned by the convergence function above
y_vals = lengths

plt.figure(figsize = (15, 7))
plt.scatter(x_vals, y_vals, s = 12)
plt.xlabel('Starting value n')
plt.ylabel('Sequence length')
plt.title('Convergence speed of aliquot sequences (length vs n)')
plt.grid(True, alpha = 0.3)
plt.show()

#This tells us that most sequences converge quickly because their lengths are quite short